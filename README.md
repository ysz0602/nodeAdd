# Node.js 第1天

## 上午总结
- Node.js 是什么
  + JavaScript 运行时
  + 既不是语言，也不是矿建，它时一个平台
- Node.js 中的 JavaScript
  + 没有 BOM、DOM
  + EcmaScript 基本的 JavaScript 语言部分
  + 在 Node 中为JavaScript 提供了一些服务器级别的 API
    * 文件操作的能力
    * http 服务的能力

## 总结

- Node 中的 JavaScript
  + EcamScript
    * 变量
    * 方法
    * 数据类型
    * 内置对象
    * Array
    * Object
    * Date
    * Math
  + 模块系统
    * 在 Node 中没有全局作用域的概念
    * 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件
    * require 加载只能是执行其中的代码， 文件与文件之间由于模块作用域，所以不会污染的问题
      - 模块完全是封闭的
      - 外部无法访问内容
      - 内部也无法访问外部
    * 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题
    * 但是某些情况下，模块与模块是需要进行通信的
    * 在每个模块中， 都提供了一个对象： `exports`
    * 该对象默认是一个空对象
    * 你要做的就是把需要被外部访问使用的成员手动的挂载到 `exports` 接口对象中
    * 然后谁来 `require` 这个模块， 谁就可以得到模块内部的 `exports` 接口对象
  + 核心模块
    * 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标记，例如
      - fs 文件操作模块
      - http 网络服务构建模块
      - os 操作系统信息模块
      - path 路径处理模块
      - 。。。。
    * 所有核心模块在使用的时候都必须手动的先使用 `require` 方法来加载，然后才可以使用，例如
      - `var fs = require('fs')`
- http
  + require
  + 端口号
    * IP 地址定位计算机
    * 端口号定位具体的应用程序
  + Content-Type
    * 服务器最好把每次相应的数据是什么类型都告诉客户端，而且要正确的告诉
    * 不同的资源对象的 Content-Type 是不一样
    * 对于文本类型的数据，最好加上编码，以防乱码
  + 通过网络发送文件
    * 发送的并不是文件，本质上来讲发送的是文件的内容
    * 当浏览器收到服务器相应内容之后，就是根据 Content-Type 进行对于的解析处理

## 复习
## 上午总结

- 代码风格
- 无分号
  + `(`
  + `[`
  + `\``
  + 最好前面补分号， 避免一些问题
  + 《编写可维护的 JavaScript》
- 服务端渲染
  + 说白了就是在服务端使用模板引擎
  + 模板引擎最早诞生于服务端，后来才发展到了前端
- 服务端渲染和客户端渲染的区别
  + 客户端渲染不利于 SEO 搜索引擎优化
  + 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的
  
## 下午总结
